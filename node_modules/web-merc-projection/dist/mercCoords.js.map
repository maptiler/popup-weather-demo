{"version":3,"sources":["../src/util.ts","../src/mercCoords.ts"],"sourcesContent":["export const EARTH_RADIUS = 6_371_008.8 // meters\nexport const EARTH_RADIUS_EQUATORIAL = 6_378_137 // meters\nexport const EARTH_RADIUS_POLAR = 6_356_752.3 // meters\n\nexport const MARS_RADIUS = 3389500 // meters\nexport const MARS_RADIUS_EQUATORIAL = 3396200 // meters\nexport const MARS_RADIUS_POLAR = 3376200 // meters\n\nexport const EPSILON = 1.0e-10\n\nexport function radToDeg (radians: number): number {\n  return radians * 180 / Math.PI\n}\n\nexport function degToRad (deg: number): number {\n  return deg * Math.PI / 180\n}\n\nexport function isFloat (n: number): boolean {\n  return n % 1 !== 0\n}\n\n// 900913 (Web Mercator) properties.\nexport const A = 6378137.0\nexport const MAXEXTENT = 20037508.342789244\n","import { A, MAXEXTENT, EARTH_RADIUS, degToRad, isFloat, radToDeg } from './util.js'\n\nimport type { BBox, Point, Sources } from './mercProj.spec.js'\n\n/** CONSTANTS **/\n// { tileSize => { zoom => [Bc, Cc, Zc, Ac] } }\ntype Cache = Record<number, Record<number, BBox>>\nconst CACHE: Cache = {}\n\nfunction getCache (zoom: number, tileSize: number): BBox {\n  if (zoom < 0 || zoom > 30) throw Error('Invalid zoom level')\n  if (isFloat(zoom)) return buildSizes(zoom, tileSize)\n  if (CACHE[tileSize] === undefined) CACHE[tileSize] = {}\n  // @ts-expect-error - we know this is NOT undefined\n  if (!Array.isArray(CACHE[tileSize][zoom])) {\n    // @ts-expect-error - we know this is NOT undefined\n    CACHE[tileSize][zoom] = buildSizes(zoom, tileSize)\n  }\n  // @ts-expect-error - we know this is NOT undefined\n  return CACHE[tileSize][zoom]\n}\n\nfunction buildSizes (zoom: number, tileSize: number): BBox {\n  const size = tileSize * Math.pow(2, zoom)\n  return [\n    size / 360,\n    size / (2 * Math.PI),\n    size / 2,\n    size\n  ]\n}\n\n/**\n * Convert Longitude and Latitude to a mercator pixel coordinate\n * */\nexport function llToPX (\n  ll: Point,\n  zoom: number,\n  antiMeridian = false,\n  tileSize = 512\n): Point {\n  const { min, max, sin, log, round } = Math\n  const [Bc, Cc, Zc, Ac] = getCache(zoom, tileSize)\n  const expansion = antiMeridian ? 2 : 1\n  const d = Zc\n  const f = min(max(sin(degToRad(ll[1])), -0.9999), 0.9999)\n  let x = d + ll[0] * Bc\n  let y = d + 0.5 * log((1 + f) / (1 - f)) * (-Cc)\n  if (!isFloat(zoom)) {\n    x = round(x)\n    y = round(y)\n  }\n  if (x > Ac * expansion) x = Ac * expansion\n  if (y > Ac) y = Ac\n\n  return [x, y]\n}\n\n/**\n * Convert mercator pixel coordinates to Longitude and Latitude\n * */\nexport function pxToLL (\n  px: Point,\n  zoom: number,\n  tileSize = 512\n): Point {\n  const { atan, exp, PI } = Math\n  const [Bc, Cc, Zc] = getCache(zoom, tileSize)\n  const g = (px[1] - Zc) / (-Cc)\n  const lon = (px[0] - Zc) / Bc\n  const lat = radToDeg(2 * atan(exp(g)) - 0.5 * PI)\n  return [lon, lat]\n}\n\n/**\n * Convert Longitude and Latitude to a mercator x-y coordinates\n */\nexport function llToMerc (ll: Point): Point {\n  const { tan, log, PI } = Math\n  let x = degToRad(A * ll[0])\n  let y = A * log(tan((PI * 0.25) + degToRad(0.5 * ll[1])))\n  // if xy value is beyond maxextent (e.g. poles), return maxextent.\n  if (x > MAXEXTENT) x = MAXEXTENT\n  if (x < -MAXEXTENT) x = -MAXEXTENT\n  if (y > MAXEXTENT) y = MAXEXTENT\n  if (y < -MAXEXTENT) y = -MAXEXTENT\n\n  return [x, y]\n}\n\n/**\n * Convert mercator x-y coordinates to Longitude and Latitude\n */\nexport function mercToLL (merc: Point): Point {\n  const { atan, exp, PI } = Math\n  const x = radToDeg(merc[0] / A)\n  const y = radToDeg((0.5 * PI) - 2 * atan(exp(-merc[1] / A)))\n  return [x, y]\n}\n\n/**\n * Convert a pixel coordinate to a tile x-y coordinate\n */\nexport function pxToTile (px: Point, tileSize = 512): Point {\n  const { floor } = Math\n  const x = floor(px[0] / tileSize)\n  const y = floor(px[1] / tileSize)\n  return [x, y]\n}\n\n/**\n * Convert a tile x-y-z to a bbox of the form `[w, s, e, n]`\n */\nexport function tilePxBounds (tile: [zoom: number, x: number, y: number], tileSize = 512): BBox {\n  const [, x, y] = tile\n  const minX = x * tileSize\n  const minY = y * tileSize\n  const maxX = minX + tileSize\n  const maxY = minY + tileSize\n  return [minX, minY, maxX, maxY]\n}\n\n/**\n * Convert a lat-lon and zoom to the tile's x-y coordinates\n */\nexport function llToTile (ll: Point, zoom: number, tileSize = 512): Point {\n  const px = llToPX(ll, zoom, false, tileSize)\n  return pxToTile(px, tileSize)\n}\n\n/** given a lon-lat and tile, find the offset in pixels */\nexport function llToTilePx (ll: Point, tile: [zoom: number, x: number, y: number], tileSize = 512): Point {\n  const [zoom, x, y] = tile\n  const px = llToPX(ll, zoom, false, tileSize)\n  const tileXStart = x * tileSize\n  const tileYStart = y * tileSize\n  return [(px[0] - tileXStart) / tileSize, (px[1] - tileYStart) / tileSize]\n}\n\n/**\n * Convert a bbox of the form `[w, s, e, n]` to a bbox of the form `[w, s, e, n]`\n * The result can be in lon-lat (WGS84) or WebMercator (900913)\n * If the input is in WebMercator (900913), the outSource should be set to 'WGS84'\n */\nexport function convert (bbox: BBox, outSource: Sources): BBox {\n  if (outSource === 'WGS84') return [...mercToLL([bbox[0], bbox[1]]), ...mercToLL([bbox[2], bbox[3]])]\n  return [...llToMerc([bbox[0], bbox[1]]), ...llToMerc([bbox[2], bbox[3]])]\n}\n\n/**\n * Convert a tile x-y-z to a bbox of the form `[w, s, e, n]`\n * The result can be in lon-lat (WGS84) or WebMercator (900913)\n * The default result is in WebMercator (900913)\n */\nexport function xyzToBBOX (\n  x: number,\n  y: number,\n  zoom: number,\n  tmsStyle = true,\n  source: Sources = '900913',\n  tileSize = 512\n): BBox {\n  // Convert xyz into bbox with srs WGS84\n  // if tmsStyle, the y is inverted\n  if (tmsStyle) y = (Math.pow(2, zoom) - 1) - y\n  // Use +y to make sure it's a number to avoid inadvertent concatenation.\n  const ll: Point = [x * tileSize, (+y + 1) * tileSize] // lower left\n  // Use +x to make sure it's a number to avoid inadvertent concatenation.\n  const ur: Point = [(x + 1) * tileSize, y * tileSize] // upper right\n  // to pixel-coordinates\n  const pxLL = pxToLL(ll, zoom, tileSize)\n  const pxUR = pxToLL(ur, zoom, tileSize)\n\n  // If web mercator requested reproject to 900913.\n  if (source === '900913') {\n    return [\n      ...llToMerc(pxLL),\n      ...llToMerc(pxUR)\n    ]\n  }\n  return [...pxLL, ...pxUR]\n}\n\n/**\n * Convert a bbox of the form `[w, s, e, n]` to a tile's bounding box\n * in the form of [minX, maxX, minY, maxY]\n * The bbox can be in lon-lat (WGS84) or WebMercator (900913)\n * The default expectation is in WebMercator (900913)\n */\nexport function bboxToXYZBounds (\n  bbox: BBox,\n  zoom: number,\n  tmsStyle = true,\n  source: Sources = '900913',\n  tileSize = 512\n): { minX: number, maxX: number, minY: number, maxY: number } {\n  const { min, max, pow, floor } = Math\n  let ll: Point = [bbox[0], bbox[1]] // lower left\n  let ur: Point = [bbox[2], bbox[3]] // upper right\n\n  if (source === '900913') {\n    ll = llToMerc(ll)\n    ur = llToMerc(ur)\n  }\n\n  const pxLL = llToPX(ll, zoom, false, tileSize)\n  const pxUR = llToPX(ur, zoom, false, tileSize)\n  // Y = 0 for XYZ is the top hence minY uses pxUR[1].\n  const x = [floor(pxLL[0] / tileSize), floor((pxUR[0] - 1) / tileSize)]\n  const y = [floor(pxUR[1] / tileSize), floor((pxLL[1] - 1) / tileSize)]\n\n  const bounds = {\n    minX: min(...x) < 0 ? 0 : min(...x),\n    minY: min(...y) < 0 ? 0 : min(...y),\n    maxX: max(...x),\n    maxY: max(...y)\n  }\n\n  if (tmsStyle) {\n    const tmsMinY = (pow(2, zoom) - 1) - bounds.maxY\n    const tmsMaxY = (pow(2, zoom) - 1) - bounds.minY\n    bounds.minY = tmsMinY\n    bounds.maxY = tmsMaxY\n  }\n\n  return bounds\n}\n\n/**\n * The average circumference of the world in meters.\n */\nconst EARTH_CIRCUMFERENCE = 2 * Math.PI * EARTH_RADIUS // meters\n\n/**\n * The circumference at a line of latitude in meters.\n */\nfunction circumferenceAtLatitude (latitude: number): number {\n  return EARTH_CIRCUMFERENCE * Math.cos(latitude * Math.PI / 180)\n}\n\n/** Convert longitude to mercator projection X-Value */\nexport function mercatorXfromLng (lng: number): number {\n  return (180 + lng) / 360\n}\n\n/** Convert latitude to mercator projection Y-Value */\nexport function mercatorYfromLat (lat: number): number {\n  const { PI, log, tan } = Math\n  return (180 - (180 / PI * log(tan(PI / 4 + lat * PI / 360)))) / 360\n}\n\n/** Convert altitude to mercator projection Z-Value */\nexport function mercatorZfromAltitude (altitude: number, lat: number): number {\n  return altitude / circumferenceAtLatitude(lat)\n}\n\n/** Convert mercator projection's X-Value to longitude */\nexport function lngFromMercatorX (x: number): number {\n  return x * 360 - 180\n}\n\n/** Convert mercator projection's Y-Value to latitude */\nexport function latFromMercatorY (y: number): number {\n  const { PI, atan, exp } = Math\n  const y2 = 180 - y * 360\n  return 360 / PI * atan(exp(y2 * PI / 180)) - 90\n}\n\n/** Convert mercator projection's Z-Value to altitude */\nexport function altitudeFromMercatorZ (z: number, y: number): number {\n  return z * circumferenceAtLatitude(latFromMercatorY(y))\n}\n\n/**\n * Determine the Mercator scale factor for a given latitude, see\n * https://en.wikipedia.org/wiki/Mercator_projection#Scale_factor\n *\n * At the equator the scale factor will be 1, which increases at higher latitudes.\n */\nexport function mercatorLatScale (lat: number): number {\n  const { cos, PI } = Math\n  return 1 / cos(lat * PI / 180)\n}\n"],"mappings":"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","names":["EARTH_RADIUS","radToDeg","radians","degToRad","deg","isFloat","A","MAXEXTENT","CACHE","getCache","zoom","tileSize","isFloat","buildSizes","size","llToPX","ll","antiMeridian","min","max","sin","log","round","Bc","Cc","Zc","Ac","expansion","d","degToRad","x","y","pxToLL","px","atan","exp","PI","g","lon","lat","radToDeg","llToMerc","tan","A","MAXEXTENT","mercToLL","merc","pxToTile","floor","tilePxBounds","tile","minX","minY","maxX","maxY","llToTile","llToTilePx","tileXStart","tileYStart","convert","bbox","outSource","xyzToBBOX","tmsStyle","source","ur","pxLL","pxUR","bboxToXYZBounds","pow","bounds","tmsMinY","tmsMaxY","EARTH_CIRCUMFERENCE","EARTH_RADIUS","circumferenceAtLatitude","latitude","mercatorXfromLng","lng","mercatorYfromLat","mercatorZfromAltitude","altitude","lngFromMercatorX","latFromMercatorY","y2","altitudeFromMercatorZ","z","mercatorLatScale","cos"]}