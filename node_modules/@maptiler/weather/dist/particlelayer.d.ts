import { MapMLGL } from "@maptiler/sdk";
import { ColoringFragmentBase } from "./coloringfragment";
import { TileLayer, TileLayerOptions } from "./tilelayer";
import { RgbaColor } from "./utils";
/**
 * Options specific to the particle visualization
 */
export interface ParticleLayerOptions {
    /**
     * Channels to read the UV values from. Defaults to `rg`
     */
    decodeChannels?: string;
    /**
     * Decode the channels as "direction + period" rather than "UV".
     *
     * If true, the first channel is assumed to be direction (0-360deg)
     * and the second to be the period (1/speed).
     */
    decodeAsWaves?: boolean;
    /**
     * Minimum encoded value.
     */
    decodeMin: number;
    /**
     * Maximum encoded value.
     */
    decodeMax: number;
    /**
     * Quantity of particles to be created. Default value is `128`.
     * Has to be a power of 2 and at least `4`.
     * The actual exact number will be `particles * particles`.
     * Try to keep this value as low as possible to optimize performance.
     *
     * The number of actually visible particles is determined by {@link density}.
     */
    maxAmount?: number;
    /**
     * Color of the particle. RGBA 0-255. Defaults to `[255, 255, 255, 192]`
     */
    color?: RgbaColor;
    /**
     * Color of the particle when moving "fast". RGBA 0-255. Defaults to {@link color}
     */
    fastColor?: RgbaColor;
    /**
     * What is considered "fast" (in px/sec) for coloring purposes.
     * Only makes sense when {@link fastColor} is used.
     */
    fastSpeed?: number;
    /**
     * Number of particles visible per 1000 px^2. Default is `2`.
     */
    density?: number;
    /**
     * Draw the particles as lines (size is length). Defaults to `false`.
     */
    drawAsLines?: boolean;
    /**
     * Use more pixels to make particles more smooth (especially when tilted).
     * Defaults to `2` for normal displays and `1` for HiDPI displays.
     */
    pixelRatio?: number;
    /**
     * Size of the particle. Defaults to `1.5`
     */
    size?: number;
    /**
     * Speed factor of the particles. Defaults to `0.001`
     */
    speed?: number;
    /**
     * Time interval (in milliseconds) how often the particles
     * are refreshed to avoid degradation.
     * Random `1/16` of the particles is always randomly reset.
     * Default value is `800`.
     */
    refreshInterval?: number;
    /**
     * How much the particles fade over time.
     * Default value is `0.1`.
     */
    fadeFactor?: number;
    /**
     * If true, the particles will only be displayed where the alpha channel is 255.
     * This is to be set to `true` for tilesets that do not cover the entire globe.
     * Default value is `false`.
     */
    useAlphaAsMask?: boolean;
    /**
     * This angle respresents the change of direction of a particle between a render call and the next. If a particle
     * changes direction abruptly with an angle greater than `angleDirectionShiftSkip`, then it is no longer rendered.
     *
     * A value of `30` (degrees) is a good compromise to reduce the "splashing" effect particle can have on the
     * side of hurricanes at semi-global-scale zoom level.
     *
     * Default: `90` (no skipping unless the particle changes direction to go backward between two render calls, which is unlikely)
     *
     */
    angleDirectionShiftSkip?: number;
    /**
     * When `true`, the speed of particles (and trail length) will be the same in number of pixel traveled per second, regardless of the
     * size of the screen, which is convenient to provide a comparable experience on mobile/desktop.
     *
     * If disabled, the particles will be slower and with a shorter trail on smalled screen such as mobile.
     *
     * Default: `false`
     */
    uniformSpeed?: boolean;
    /**
     * If this is `true`, the particles gets slighly larger as they become faster.
     * Default: `false`
     */
    fastIsLarger?: boolean;
}
/**
 * Extended version of {@link TileLayer}, which does particle-based animation on top the data.
 *
 * The standard raster visualization of {@link TileLayer} can be used simultanously over the same data.
 */
export declare class ParticleLayer extends TileLayer {
    private rttScene;
    private rttCamera;
    private rttMaterial;
    private rttMesh;
    private particleTexturePrev;
    private particleTexture0;
    private particleTexture1;
    private particleMaterial;
    private particles;
    private particleBackground;
    private accumulator;
    private accumulatorDrawMesh;
    private flipFlop;
    private numParticles;
    private particleDensity;
    private refreshInterval;
    private fadeFactor;
    private particleColor;
    private particleFastColor;
    private particleFastSpeed;
    private particleSize;
    private drawAsLines;
    private particleSpeed;
    private pixelRatio;
    private prevRenderTime;
    private lastRenderTime;
    private forceRender;
    private rttTimestep;
    private tileGridPass;
    /**
     * @param id Unique identifier of the layer in the map.
     * @param options
     * @param particleOptions
     * @param coloringFragments If not null, the same data will also be displayed as raster.
     */
    constructor(id: string, options: TileLayerOptions | null, particleOptions: ParticleLayerOptions | null, coloringFragments?: ColoringFragmentBase[] | null);
    initParticle(options: TileLayerOptions, particleOptions: ParticleLayerOptions, coloringFragments?: ColoringFragmentBase[] | null): void;
    onAdd(map: MapMLGL, gl: WebGLRenderingContext | WebGL2RenderingContext): void;
    private generateRandomizeParticleTexture;
    private randomizeParticles;
    /**
     * Returns the ratio between the number of actually visible particle
     * (to statisfy the specified density) and the maximum amount (maxAmount).
     *
     * Value >1 mean that more particles would be utilized if availabe.
     *
     * Useful for debugging and fine-tuning client application.
     */
    getParticleUtilization(): number;
    setOpacity(opacity: number): void;
    protected disposeObjects(): void;
    protected onResize(): void;
    protected onMoveEnd(): void;
    refresh(): void;
    prerenderInternal(): void;
    renderInternal(): void;
}
