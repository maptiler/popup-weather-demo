import { CustomLayerInterface, Map } from "@maptiler/sdk";
import { MapMLGL } from "@maptiler/sdk";
import { Extent } from "ol/extent.js";
import * as three from "three";
import { ColoringFragmentBase, MultiChannelGradientColoringFragment } from "./coloringfragment";
import { Tile, TileTextureSource } from "./tiletexturesource";
import { TimeFrameAnimation } from "./timeframeanimation";
/**
 * A 4x4 matrix type
 */
export type Mat4 = [
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number
] | Float32Array;
/**
 * Key-value list of tile. The IDs are of the form `"z/x/y"` and the value is true.
 * See it as a Set.
 */
export type TileList = {
    [key: string]: true;
};
/**
 * Image data
 */
export interface ImageData {
    /**
     * The pixel data
     */
    data: Uint8Array;
    /**
     * The number of channels of the image (example: if image is RGBA then channels is 4)
     */
    channels: number;
    /**
     * Width of the image
     */
    width: number;
    /**
     * Height of the image
     */
    height: number;
}
/**
 * Options for the TileLayer construction
 */
export interface TileLayerOptions {
    /**
     * Minimum zoom of the tile pyramids that will be added into this layer.
     */
    minZoom?: number;
    /**
     * Maximum zoom.
     */
    maxZoom?: number;
    /**
     * Limited bounds of the tile pyramids -- tiles outside this will not be loaded.
     *
     * `[west, south, east, north]` in degrees
     */
    bounds?: [number, number, number, number];
    /**
     * Rendering areas with opacity < 1.0
     * Default value is false.
     */
    renderTransparentArea?: boolean;
    /**
     * Indicated whether the the function `map.triggerRepaint()` should be called
     * when the animation is paused.
     */
    repaintOnPausedAnimation?: boolean;
    /**
     * Linear interpolation between keyframes when true, or jumping from a keyframe to the
     * next when false;
     */
    timeInterpolation?: boolean;
    /**
     * Bilinear interpolation of category color (but not of category value) when true (requires more performance).
     * No interpolation when false.
     * Applies only to TileLayers using MultiChannelGradientColoringFragment
     * (as the other types of Coloring Fragment are not compatible with categories)
     */
    categorySmoothTransition?: boolean;
    /**
     * Enables the local smoothing if tue.
     * Default: false
     */
    localSmoothing?: boolean;
    /**
     * Number of adjacent texture reads used to compute a smooth average for each pixel on screen.
     * If `0`, then only the central point is read, which does the same as `localSmoothing = false`.
     * If very high (32 or more), will have a performance impact on low-end devices.
     * Default: 16
     */
    nbSmoothingBins?: number;
    /**
     * The distance of the smoothing bins are dependant of the zoom-level. The distance is the longest at z0
     * and decays. maxSmoothingDistance is the distance at z0.
     * Default: 10
     */
    maxSmoothingDistance?: number;
    /**
     * The decay factor has an influence on how the distance between the reference texture and its adjacent bins
     * diminishes as the zoom level gets higher.
     * If smoothingDistanceDecayFactor is closer to `0`, the decaying function will have the shape of the inverse
     * function (fast decay very quickly). If smoothingDistanceDecayFactor is closer to `100`,
     * the decay is considered linear.
     * Default: 12
     */
    smoothingDistanceDecayFactor?: number;
    /**
     * If `true`, will load the lower zoom level (up to z0) if the tile of requested zoom level
     * is not ready/loaded. This will lead to visually smoother transitions as zooming in but will
     * require fetching more tiles at high zoom level.
     * If `false`, will load only the tile of the requested zoom level.
     * Default: `true`
     */
    loadLowerZoomLevels?: boolean;
}
/**
 * Special layer that can be added to MapTiler SDK's Map.
 *
 * Consists of multiple timeframes, every frame is a tile pyramid in a different moment in time.
 *
 * The individual frames are smoothly animated.
 *
 * Decoding of the data and their visual representation is configurable.
 */
export declare class TileLayer extends TimeFrameAnimation<TileTextureSource> implements CustomLayerInterface {
    id: string;
    type: "custom";
    renderingMode: "3d";
    /**
     * Camera used to render the tiles
     */
    protected readonly camera: three.Camera;
    /**
     * Scene to add the tiles to
     */
    protected readonly scene: three.Scene;
    /**
     * Array of array of Tiles (plane geometry meshes)
     */
    protected readonly slippyTiles: Array<Array<three.Mesh>>;
    /**
     * Instance of MapTiler SDK map
     */
    protected map: Map | null;
    /**
     * Renderer to render the tiles
     */
    protected renderer: three.WebGLRenderer | null;
    /**
     * The shader material of the tiles (with uniforms such as textures, time, etc.)
     */
    private material;
    /**
     * The plane geometry used for all the tiles
     */
    private geometry;
    /**
     * TODO
     */
    private flusher;
    /**
     * A TileGrid (from OL) that contains some tile logic such as mercator to index, etc.
     */
    private tilegrid;
    /**
     * Extent as in OL
     */
    private extent;
    /**
     * Indicated whether the the function `map.triggerRepaint()` should be called
     * when the animation is paused.
     */
    private repaintOnPausedAnimation;
    /**
     * Manages a pool of rawshadermaterial to reuse, rather cloning endlessly
     */
    private materialPool;
    private bluringNodePasses;
    private tileThreeContainer;
    /**
     * ratio to wich the extent is enlarged when using the method `.getVisibleExtent()`
     */
    protected extentScale: number;
    /**
     * The event `"extentChanged"` is emitted when the intersection-over-union ration from the former extent to the new
     * is below this.extentChangedThreshold
     */
    private extentChangedThreshold;
    private lastExtent;
    private timeInterpolation;
    private isReady;
    private defaultTexture;
    private onMoveEndListener;
    private onResizeListener;
    private onMoveListener;
    private coloringFragments;
    private multiChannelColoringFragment;
    private loadLowerZoomLevels;
    /**
     *
     * @param id Unique identifier of the layer in the map.
     * @param options
     * @param coloringFragments
     */
    constructor(id: string, options: TileLayerOptions | null, coloringFragments?: ColoringFragmentBase[] | null, multiChannelColoringFragment?: MultiChannelGradientColoringFragment | null);
    init(options: TileLayerOptions, coloringFragments?: ColoringFragmentBase[] | null, multiChannelColoringFragment?: MultiChannelGradientColoringFragment | null): void;
    /**
     * Remove the current tiles of the tile grid from the scene and reinstanciate them all
     * (three.Mesh) based onthe arguments, then add them to the scene again.
     * Note: The tils positions are not updated yet, this is performed by `.updateSlippyTile()`
     * @param width
     * @param height
     */
    private updateSlippyTileGrid;
    private validateSource;
    /**
     * Adds another frame to the animation.
     * @param time Time of the data in this frame. Should be unique.
     * @param url URL to the tiles. Expected to have `{zxy}` placeholder to be dynamically replaced with `z/x/y` coordinates.
     */
    addSource(time: number, url: string, loadedCallback?: ((tile: Tile, url?: string, error?: ErrorEvent | null) => void) | null): void;
    /**
     * Removes frame
     */
    removeSource(time: number): void;
    /**
     * Ge the Extent as defined in OL
     * @param scale
     * @returns
     */
    getVisibleExtent(scale?: number): Extent | null;
    /**
     * Get the list of all the tiles wanted for this extent and from the min zoom to the max zoom.
     * This is used to prevent updating tiles that are not in this list in `.updateSlippyTile()`
     * @param currentZ
     * @returns
     */
    getWantedTiles(currentZ: number): TileList;
    /**
     * Changes the global opacity of the layer.
     * Default is `1`
     *
     * @param opacity Opacity 0-1.
     */
    setOpacity(opacity: number): void;
    /**
     * Method from CustomLayerInterface, called when the layer is added to the map
     * @param map
     * @param gl
     */
    onAdd(map: MapMLGL, gl: WebGLRenderingContext | WebGL2RenderingContext): void;
    onMove(): void;
    refresh(): void;
    onRemove(_map: MapMLGL, _gl: WebGLRenderingContext | WebGL2RenderingContext): void;
    /**
     * Remove some data allocated (not of the tiles)
     */
    protected disposeObjects(): void;
    /**
     * Callback when the window is resized.
     */
    protected onResize(): void;
    protected onMoveEnd(): void;
    /**
     * Get the TilePlacement from a zxy
     * @param source
     * @param load
     * @param z
     * @param x
     * @param y
     * @param originalTileCoordinates
     * @returns
     */
    private getTilePlacement;
    /**
     * Update the tile's mesh position and size, as well each tile material uniforms
     * (time, texture, etc.)
     * @returns
     */
    protected updateSlippyTiles(): void;
    /**
     * This method is called from CustomLayerInterface before rendering.
     * This is used to apply the map matrix to the local camera
     * to te
     * @param _gl
     * @param matrix
     */
    prerender(_gl: WebGLRenderingContext | WebGL2RenderingContext, matrix: Mat4): void;
    protected prerenderInternal(): void;
    /**
     * This method is called from CustomLayerInterface and is used to render the local tiles
     * into the MapTiler SDK context
     * @param _gl
     * @param _matrix
     */
    render(_gl: WebGLRenderingContext | WebGL2RenderingContext, _matrix: Mat4): void;
    protected renderInternal(): void;
    /**
     * Get layer image decoded value (decoded means on the real world interval such as provided [decode.min, decode.max])
     * @param lng
     * @param lat
     * @param source
     * @returns
     */
    private pickFrame;
    /**
     * Picks the best currently available values at the position.
     *
     * The values are read from the already loaded tiles at the current time.
     *
     * Return the interpolated array of decoded values
     * of the same length as the number of specified coloring fragments.
     *
     * If the coloring fragments uses more channels (e.g. "rg"),
     * the corresponding value is an array of `[r value, g value, sqrt(r^2 + g^2)]`.
     *
     * @param lng
     * @param lat
     * @returns Array of decoded interpolated values.
     */
    pick(lng: number, lat: number): number[] | null;
    protected getMapOrThrow: () => Map;
    protected getRendererOrThrow: () => three.WebGLRenderer;
    forceRepaint(): void;
    /**
     * Get the current mixed image as a ImageData, meaning with pixel data, width, height and number of channels
     * @param options.zxy The tile ID
     * @param options.blurKernel Size of the bluring kernel
     * @param options.outputSize Size of the outpout image (-1 means same as input). Note that the bluring is applied on an image of this size.
     * @returns
     */
    computeCurrentMixedImage({ zxy, blurKernel, outputSize, channel, }: {
        zxy?: string;
        blurKernel?: number;
        outputSize?: number;
        channel?: string;
    }): ImageData | null;
    /**
     * Enables data interpolation between keyframes when true. Only shows keyframe data when false.
     * @param ti
     */
    setTimeInterpolation(ti: boolean): void;
    /**
     * Enable smoothing category color when true. Hard edge between categories when false.
     * This seeting applies only to TileLayers using MultiChannelGradientColoringFragment
     * as the other types of oloring fragment do not use categories.
     * @param cst
     */
    setCategorySmoothTransition(cst: boolean): void;
    /**
     * If `true`, enables the local smoothing
     * @param s
     */
    setLocalSmoothing(s: boolean): void;
    /**
     * Defines the size of the smoothing kernel
     * @param d
     */
    setMaxSmoothingDistance(d: number): void;
    /**
     * Defines by what factor the smoothing kernel size is reduced with increasing zoom level
     * @param f
     */
    setSmoothingDistanceDecayFactor(f: number): void;
    /**
     * Get whether or not the frames continues to rendered on a paused animation
     * @returns
     */
    getRepaintOnPausedAnimation(): boolean;
    /**
     * If `true`, even the paused animation is rendered up to 60 times
     * per seconds. If `false`, the rendering is paused when the animation is paused.
     * Pausing the animation has side effects:
     * - it lowers energy consumtion
     * - it prevents overheating
     * - it pauses time-independant annimation (arrows, particles)
     * @param r
     */
    setRepaintOnPausedAnimation(r: boolean): void;
}
