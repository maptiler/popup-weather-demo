import { Pixel, RgbaColor, UsedRgbChannel } from "./utils";
/**
 *
 */
export declare class ColoringFragmentBase {
    private readonly code;
    private readonly decode;
    /**
     * @param code Inputs: `vec4 dst`, `vec4 data`. Outputs into `dst`.
     */
    constructor(code: string, decode: DecoderOptions);
    /**
     * Get the value in the unit interval [0, 1] computed with `.decode.min` and `.decode.max`
     * @param value
     * @returns
     */
    codeValue(value: number): number;
    /**
     * Given a value in the unit interval [0, 1] get the real world value bounded by `.decode.min` and `.decode.max`
     * @param value
     * @returns
     */
    decodeValue(value: number): number;
    /**
     * Get real world values of the given pixel (with rgb or rgba in [0, 1]) for the channel(s)
     * specified in `.decode.channel`
     * @param pixel
     * @returns
     */
    decodeChannel(pixel: Pixel): number | number[];
    /**
     * Generate shader/GLSL code for blending
     * @param name
     * @returns
     */
    getBlendCode(name: string): string;
    /**
     * Generate shader/GLSL code
     * @param name
     * @returns
     */
    getCode(name: string): string;
}
/**
 * Describes how to read the data value from the input files.
 */
export interface DecoderOptions {
    /**
     * Channel to be used to read the value from - `"r"`/`"g"`/`"b"`.
     * If more letters are present (`"rg"`), each channel is decoded separately and
     * then the vector length is calculated.
     *
     * Irrelevant when decoding data for `VolumeLayer`.
     */
    channel: UsedRgbChannel;
    /**
     * Minimum value encoded in each channel. (Value of `0` in the raster = this value.)
     */
    min: number;
    /**
     * Maximum value encoded in each channel.
     */
    max: number;
}
/**
 * ColorStop
 */
export interface ColorStop {
    /**
     * The "value" at which this ColorStop should be applied.
     */
    value: number;
    /**
     * RGB[A] - Array of 3-4 numbers. 0-255 per channel.
     */
    color: RgbaColor;
}
/**
 * GradientColoringFragmentOptions
 */
export type GradientColoringFragmentOptions = {
    decode: DecoderOptions;
    /**
     * The color stops of the gradient.
     */
    stops?: ColorStop[];
    /**
     * Apply the gradient smoothly, rather then discrete steps.
     */
    smooth?: boolean;
    /**
     * 0-1
     */
    opacity?: number;
};
/**
 * Use color gradient to generate coloring from the pixel values.
 */
export declare class GradientColoringFragment extends ColoringFragmentBase {
    /**
     */
    constructor(options: GradientColoringFragmentOptions);
}
/**
 * OpacityColoringFragmentOptions
 */
export interface OpacityColoringFragmentOptions {
    decode: DecoderOptions;
    /**
     * RGB[A] - Array of 3-4 numbers. 0-255 per channel.
     */
    color?: RgbaColor;
    /**
     * 0-1
     */
    opacity?: number;
}
/**
 * Use a single color, only change opacity based on the decoded value.
 */
export declare class OpacityColoringFragment extends ColoringFragmentBase {
    /**
     * .
     */
    constructor(options: OpacityColoringFragmentOptions);
}
export interface MultiChannelDecoderOptions {
    /**
     * In the polynomial f(x) = ax^2 + bx + c
     * polynomialCoefDegree2 is "a"
     */
    polynomialCoefDegree2: number;
    /**
     * In the polynomial f(x) = ax^2 + bx + c
     * polynomialCoefDegree2 is "b"
     */
    polynomialCoefDegree1: number;
    /**
     * In the polynomial f(x) = ax^2 + bx + c
     * polynomialCoefDegree2 is "c"
     */
    polynomialConstant: number;
}
/**
 * The color stops as to be used by MultiChannelGradientColoringFragment
 */
export type StopsPerCategoryType = {
    /**
     * A category. Categories are the values stored in the alpha channel (in [0, 255]).
     * If the category value is `"all"` then the color stops will apply to all categories
     * and if there are other StopsPerCategory for specific category number, they will be ignored.
     */
    category?: number | "all";
    /**
     * The color stops are defining the colormap to be used.
     */
    stops: Array<ColorStop>;
};
/**
 * Options as per howto interpret image channels in the context of a multi channel gradient coloring fragment
 */
export type MultiChannelGradientColoringFragmentOptions = {
    /**
     * Polynomial information as per how to decode the multi channel value.
     */
    decode: MultiChannelDecoderOptions;
    /**
     * The color stops for each gradient. There is a gradient per category.
     */
    stopsPerCategory: Array<StopsPerCategoryType>;
    /**
     * Apply the gradient smoothly, rather then discrete steps.
     */
    smooth?: boolean;
    /**
     * 0-1
     */
    opacity?: number;
};
export declare class MultiChannelGradientColoringFragment {
    private decode;
    private stopsPerCategory;
    private smooth;
    private opacity;
    private code;
    constructor(options: MultiChannelGradientColoringFragmentOptions);
    getCode(): string;
    decodeChannel(pixel: Pixel): number[];
}
