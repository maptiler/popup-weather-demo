import { WebGLRenderer, Texture, Vector2, Vector3, Color, Vector4, Quaternion, Matrix3, Matrix4, CubeTexture } from "three";
export type ThreeUniformType = number | boolean | Vector2 | Vector3 | Float32Array | Array<number> | Color | Vector4 | Quaternion | Matrix3 | Matrix4 | Int32Array | Texture | CubeTexture;
/**
 * Singleton of a WebGlRenderer
 * @returns
 */
export declare function getAdhocRenderer(): WebGLRenderer;
/**
 * An instance of SinglePassNode is used to produce a rendering. This could take uniforms such as texture or parameters
 * and create output of parametric sizes.
 * A good example of usage is to use two SinglePassNode to create a gaussian blur as the output of a SinglePassNode can be the resulting image as a texture
 * to be sent to a second pass.
 */
export default class SinglePassNode {
    private renderer;
    private camera;
    private scene;
    private renderTarget;
    private material;
    private size;
    /**
     *
     * @param width width of the output
     * @param height height of the output
     * @param renderer optional existing renderer to use
     */
    constructor(width: number, height: number, renderer?: WebGLRenderer);
    /**
     * Get the output texture
     * @param forceDataTexture Makes a deep copy of the texture data to return a `THREE.DataTexture`. This is much slower
     * but allows this instance to be disposed while keeping a copy of the texture.
     * @returns
     */
    getOutputTexture(forceDataTexture?: boolean): Texture | null;
    /**
     * Set the size of the output
     * @param width
     * @param height
     * @returns
     */
    setSize(width: number, height: number): void;
    /**
     * Set the vertex shader for this pass
     * @param shader
     */
    setVertexShader(shader: string): void;
    /**
     * Set the fragment shader for this pass
     * @param shader
     */
    setFragmentShader(shader: string): void;
    /**
     * Add a uniform
     * @param name
     * @param value
     */
    setUniform(name: string, value: ThreeUniformType): void;
    /**
     * Dynamically replace some string in a shader (`name`) by others (`value`)
     * @param name
     * @param value
     */
    setDefine(name: string, value: string | number | boolean): void;
    /**
     * Retrieve the pixel data as a single dimension array of RGBA.
     * This can be slow because of memory transfer from GPU to CPU
     */
    getPixelData(): Uint8Array;
    /**
     * Get the defined size of the output
     * @returns
     */
    getSize(): Vector2;
    /**
     * Run the shader code. The result is then stored internaly in a `THREE.RenderTarget`
     * @returns
     */
    process(): Texture;
    /**
     * Opens the output image in a separate window for debugging purposes.
     */
    debugAsPNG(): void;
    /**
     * Free the render target memory
     */
    dispose(): void;
}
